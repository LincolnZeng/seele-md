
# Sharding

Seele sharding infrastructure greatly improved the scalability and effeciency of SeeleMainnet. An [introduction](https://medium.com/@SeeleTech/an-introduction-to-seeles-sharding-implementation-92ebf6e5aa53) is availble on medium explaining the details of how shards communicate through Seele's sharding protocol. SeeleMainnet currently consists of four shards: each shard containing its own chain and accounts available to that shard. As a kind note, here are some notable implications, of sharding, for Seele's blockchain:

### Accounts

Each user account consist of: private-key, public-key, address. The shard of addresses are determined with the following logic:

```js
function shardOfAddress(address){
  var maxShard = 4
  var sum      = 0
  var buf = Buffer.from(address.substring(2), 'hex')
  for (const pair of buf.entries()) {if (pair[0] < 18){sum += pair[1]}}
  sum += (buf.readUInt16BE(18) >> 4)
  return (sum % maxShard) + 1
}

var address = '0x6b11bb0c9167ccd1bd9e4af80b997ed822e128a1'
console.log(shardOfAddress(address));
// prints 1
```

A smart contract also has an account, where only its address is revealed in the receipt of the transaction that deployed this contract to one of the shards on SeeleMainnet. The shard of the contract address is also determined by the logic above. Thus all seele accounts are inherently "shardful."

### Nodes

Refer to [nodes](./../go-seele/gettingStarted.md) for pre-knowledge.

These "shardful" accounts are used in node configuration files. As implied in a node's configuration file, a node can only run on one shard: would maintain a **full chain** for the shard its in, and three **light chains** for the other shards to accompany seele's sharding protocol. A node can only mine on and provide services based on the full chain.

Thus, a node will ignore a transaction data request if the sender is from alien shards. For the same reason, the ```.basic.coinbase``` field in the node's configuration file must belong to the shard specified in ```.genesis.shard```, as mining reward is documented in the form of a transaction in this shard.

### Transactions

Transactions between accounts will be handled differently when accounts are of the same shard verses when accounts are from different shards. When the sender and receiver are from the __**same**__ shard, the transaction is considered complete once the broadcasted transaction data is packed into the next block on the shard's chain **(15 seconds expected)**. It is, however, encouraged to wait for the data to be packed 2-3 blocks deep for stability(against soft forks), and 120 blocks deep for security (against attacks).

When sender and receiver are from **different** shards, the broadcasted transaction data is first packed into the next block on the sender's shard's chain, a **debt data** will be created in the receiver's shard's **debt pool**. The debt data will be taken out from debt pool to be broadcasted to the receiver's shard's chain when its matching transaction data is packed 120 blocks deep. The transaction is considered complete once the debt data is packed into the next block on the receiver's shard's chain **(30 minutes expected)**. The same waiting is encouraged for debt stability and security.

Yes, like for **cross-shard transactions**, there is a **transaction pool**, for **transaction data** for **same-shard transactions**, refer to json-rpc docs to know how to monitor transaction pool.

### Contract

Refer to [contract](./../contract/contract.md) for pre-knowledge.

Contracts are **deployed** and **employed** through transactions, or **called**. Contract address, generated by node's internal vm, will always belong to the shard its deployment transaction was packaged.


Since interactions involve transactions that are only fast if they're same-sharded, seele is yet to support cross-shard transactions when it comes to contracts. That said, the account one uses to employ a contract **must** be of the same shard as the contract's shard.

For example, seele's contract language is solidity, and with solidity comes the functionality to refund from the contract's balance to a user if the coder designed so. If when employing such refund function, the receiver is from an alien shard, the refund amount will be irreversibly lost.
